import * as blakejs from 'blakejs';
import { JSONPath } from 'jsonpath-plus';

import { TezosLanguageUtil } from '../../TezosLanguageUtil';
import { TezosMessageUtils } from '../../TezosMessageUtil';
import { TezosNodeReader } from '../../TezosNodeReader';
import { TezosNodeWriter } from '../../TezosNodeWriter';
import { KeyStore, Signer } from '../../../../types/ExternalInterfaces';
import * as TezosTypes from '../../../../types/tezos/TezosChainTypes';

/**
 * Interface for the FA2.0 contract implementation outlined here: https://gitlab.com/tzip/tzip/-/tree/master/proposals/tzip-12/tzip-12.md.
 * 
 * Compatible with the contract as of May 2, 2020 from https://github.com/tqtezos/smart-contracts/blob/fa2-single-e/single_asset/out/fa2_single_asset.tz
 */
export namespace SingleAssetTokenHelper {
    /**
     * Gets the contract code at the specified address at the head block and compares it to the known hash of the code. This function processes Micheline format contracts.
     * 
     * 
     * @param server Destination Tezos node.
     * @param address Contract address to query.
     */
    export async function verifyDestination(server: string, address: string): Promise<boolean> {
        const contract = await TezosNodeReader.getAccountForBlock(server, 'head', address);

        if (!!!contract.script) { throw new Error(`No code found at ${address}`); }

        const k = Buffer.from(blakejs.blake2s(JSON.stringify(contract.script.code), null, 16)).toString('hex');

        if (k !== '0e3e137841a959521324b4ce20ca2df7') { throw new Error(`Contract does not match the expected code hash: ${k}, '0e3e137841a959521324b4ce20ca2df7'`); }

        return true;
    }

    /**
     * In contrast to verifyDestination, this function uses compares Michelson hashes.
     * 
     * @param script 
     */
    export function verifyScript(script: string): boolean {
        const k = Buffer.from(blakejs.blake2s(TezosLanguageUtil.preProcessMichelsonScript(script).join('\n'), null, 16)).toString('hex');

        if (k !== 'b77ada691b1d630622bea243696c84d7') { throw new Error(`Contract does not match the expected code hash: ${k}, 'b77ada691b1d630622bea243696c84d7'`); }

        return true;
    }

    export async function deployContract(server: string, signer: Signer, keystore: KeyStore, fee: number, administrator: string, name: string, symbol: string, tokenid: number, scale: number, pause: boolean = true, supply: number = 0, gas: number = 400_000, freight: number = 8_000): Promise<string> {
        const contract = `{ parameter (or (or (or %admin (bool %pause) (address %set_admin)) (or %assets (or (or (pair %balance_of (contract %callback (list (pair (nat %balance) (pair %request (address %owner) (nat %token_id))))) (list %requests (pair (address %owner) (nat %token_id)))) (pair %is_operator (contract %callback (pair (bool %is_operator) (pair %operator (pair (address %operator) (address %owner)) (or %tokens (unit %all_tokens) (set %some_tokens nat))))) (pair %operator (pair (address %operator) (address %owner)) (or %tokens (unit %all_tokens) (set %some_tokens nat))))) (or (contract %permissions_descriptor (pair (pair (option %custom (pair (option %config_api address) (string %tag))) (or %operator (or (unit %no_transfer) (unit %owner_or_operator_transfer)) (unit %owner_transfer))) (pair (or %receiver (or (unit %optional_owner_hook) (unit %owner_no_op)) (unit %required_owner_hook)) (or %sender (or (unit %optional_owner_hook) (unit %owner_no_op)) (unit %required_owner_hook))))) (pair %token_metadata (contract %callback (list (pair (pair (pair (nat %decimals) (map %extras string string)) (pair (string %name) (string %symbol))) (nat %token_id)))) (list %token_ids nat)))) (or (or (pair %total_supply (contract %callback (list (pair (nat %token_id) (nat %total_supply)))) (list %token_ids nat)) (list %transfer (pair (pair (nat %amount) (address %from_)) (pair (address %to_) (nat %token_id))))) (list %update_operators (or (pair %add_operator (pair (address %operator) (address %owner)) (or %tokens (unit %all_tokens) (set %some_tokens nat))) (pair %remove_operator (pair (address %operator) (address %owner)) (or %tokens (unit %all_tokens) (set %some_tokens nat)))))))) (or %tokens (list %burn_tokens (pair (nat %amount) (address %owner))) (list %mint_tokens (pair (nat %amount) (address %owner))))) ;
            storage (pair (pair %admin (address %admin) (bool %paused)) (pair %assets (pair (pair (big_map %ledger address nat) (pair %metadata (pair (pair (nat %decimals) (map %extras string string)) (pair (string %name) (string %symbol))) (nat %token_id))) (pair (big_map %operators (pair address address) bool) (pair %permissions_descriptor (pair (option %custom (pair (option %config_api address) (string %tag))) (or %operator (or (unit %no_transfer) (unit %owner_or_operator_transfer)) (unit %owner_transfer))) (pair (or %receiver (or (unit %optional_owner_hook) (unit %owner_no_op)) (unit %required_owner_hook)) (or %sender (or (unit %optional_owner_hook) (unit %owner_no_op)) (unit %required_owner_hook)))))) (nat %total_supply))) ;
            code { LAMBDA (pair address (big_map address nat)) nat { DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; GET ; IF_NONE { PUSH nat 0 } { DUP ; DIP { DROP } } ; DIP { DROP } } ; DUP ; LAMBDA (pair (lambda (pair address (big_map address nat)) nat) (pair (list (pair (pair (nat %amount) (option %from_ address)) (pair (option %to_ address) (nat %token_id)))) (big_map address nat))) (big_map address nat) { DUP ; CAR ; SWAP ; CDR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ITER { SWAP ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; CAR ; CDR ; IF_NONE { DIG 1 ; DUP ; DUG 2 } { DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DUP ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DIG 9 ; DUP ; DUG 10 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; CAR ; CDR ; DIG 1 ; DUP ; DUG 2 ; SUB ; ISNAT ; IF_NONE { PUSH string "INSUFFICIENT_BALANCE" ; FAILWITH } { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; COMPARE ; EQ ; IF { DIG 2 ; DUP ; DUG 3 ; DIG 4 ; DUP ; DUG 5 ; NONE nat ; SWAP ; UPDATE } { DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; SOME ; DIG 5 ; DUP ; DUG 6 ; UPDATE } ; DIP { DROP } } ; DIP { DROP 5 } } ; DIG 1 ; DUP ; DUG 2 ; CDR ; CAR ; IF_NONE { DUP } { DIG 1 ; DUP ; DUG 2 ; DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DUP ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DUP ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DIG 10 ; DUP ; DUG 11 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; CAR ; CDR ; DIG 1 ; DUP ; DUG 2 ; ADD ; DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; SOME ; DIG 5 ; DUP ; DUG 6 ; UPDATE ; DIP { DROP 6 } } ; DUP ; DIP { DROP 5 } } ; DIP { DROP 2 } } ; SWAP ; APPLY ; LAMBDA (or (unit %all_tokens) (set %some_tokens nat)) unit { DUP ; IF_LEFT { DROP ; UNIT } { PUSH nat 1 ; DIG 1 ; DUP ; DUG 2 ; SIZE ; COMPARE ; NEQ ; IF { PUSH string "TOKEN_UNDEFINED" ; FAILWITH } { DUP ; PUSH nat 0 ; MEM ; IF { UNIT } { PUSH string "TOKEN_UNDEFINED" ; FAILWITH } } ; DIP { DROP } } ; DIP { DROP } } ; LAMBDA (list nat) unit { DUP ; IF_CONS { PUSH nat 0 ; DIG 2 ; DUP ; DUG 3 ; SIZE ; COMPARE ; NEQ ; IF { PUSH string "TOKEN_UNDEFINED" ; FAILWITH } { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; COMPARE ; EQ ; IF { UNIT } { PUSH string "TOKEN_UNDEFINED" ; FAILWITH } } ; DIP { DROP 2 } } { PUSH string "NO_TOKEN_ID" ; FAILWITH } ; DIP { DROP } } ; LAMBDA (list (pair (nat %amount) (address %owner))) nat { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; ITER { SWAP ; PAIR ; DUP ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ADD ; DIP { DROP } } ; DIP { DROP } } ; LAMBDA (pair (address %admin) (bool %paused)) unit { DUP ; CAR ; SENDER ; COMPARE ; NEQ ; IF { PUSH string "NOT_AN_ADMIN" ; FAILWITH } { UNIT } ; DIP { DROP } } ; DIG 6 ; DUP ; DUG 7 ; CDR ; DIG 7 ; DUP ; DUG 8 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DIG 2 ; DUP ; DUG 3 ; CAR ; DIG 4 ; DUP ; DUG 5 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; SWAP ; CAR ; PAIR ; DIP { DROP } ; NIL operation ; PAIR ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; SWAP ; CDR ; SWAP ; PAIR ; DIP { DROP } ; NIL operation ; PAIR ; DIP { DROP } } ; DIP { DROP 2 } ; DIG 4 ; DUP ; DUG 5 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CDR ; SWAP ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 3 } } { DIG 2 ; DUP ; DUG 3 ; CAR ; CDR ; IF { PUSH string "PAUSED" ; FAILWITH } { UNIT } ; DIG 3 ; DUP ; DUG 4 ; CDR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DUP ; IF_LEFT { DUP ; IF_LEFT { DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DUP ; CDR ; MAP { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; COMPARE ; NEQ ; IF { PUSH string "TOKEN_UNDEFINED" ; FAILWITH } { DIG 2 ; DUP ; DUG 3 ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIG 18 ; DUP ; DUG 19 ; SWAP ; EXEC ; DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DIP { DROP } } ; DIP { DROP } } ; DIG 1 ; DUP ; DUG 2 ; CAR ; PUSH mutez 0 ; DIG 2 ; DUP ; DUG 3 ; TRANSFER_TOKENS ; DIP { DROP 3 } ; DIG 4 ; DUP ; DUG 5 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 2 } } { DUP ; CDR ; CDR ; DIG 13 ; DUP ; DUG 14 ; SWAP ; EXEC ; DIG 1 ; DUP ; DUG 2 ; CAR ; PUSH mutez 0 ; DIG 3 ; DUP ; DUG 4 ; CDR ; DIG 7 ; DUP ; DUG 8 ; CAR ; CDR ; CAR ; DIG 5 ; DUP ; DUG 6 ; CDR ; CAR ; CAR ; DIG 6 ; DUP ; DUG 7 ; CDR ; CAR ; CDR ; PAIR ; GET ; IF_NONE { PUSH bool False } { DUP ; DIP { DROP } } ; PAIR ; TRANSFER_TOKENS ; DIG 5 ; DUP ; DUG 6 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 3 } } ; DIP { DROP } } { DUP ; IF_LEFT { DUP ; PUSH mutez 0 ; DIG 5 ; DUP ; DUG 6 ; CAR ; CDR ; CDR ; TRANSFER_TOKENS ; DIG 4 ; DUP ; DUG 5 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 2 } } { DUP ; CDR ; DIG 12 ; DUP ; DUG 13 ; SWAP ; EXEC ; DIG 1 ; DUP ; DUG 2 ; CAR ; PUSH mutez 0 ; NIL (pair (pair (pair (nat %decimals) (map %extras string string)) (pair (string %name) (string %symbol))) (nat %token_id)) ; DIG 7 ; DUP ; DUG 8 ; CAR ; CAR ; CDR ; CONS ; TRANSFER_TOKENS ; DIG 5 ; DUP ; DUG 6 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 3 } } ; DIP { DROP } } ; DIP { DROP } } { DUP ; IF_LEFT { DUP ; IF_LEFT { DUP ; CDR ; DIG 12 ; DUP ; DUG 13 ; SWAP ; EXEC ; DIG 1 ; DUP ; DUG 2 ; CAR ; PUSH mutez 0 ; NIL (pair (nat %token_id) (nat %total_supply)) ; DIG 7 ; DUP ; DUG 8 ; CDR ; PUSH nat 0 ; PAIR ; CONS ; TRANSFER_TOKENS ; DIG 5 ; DUP ; DUG 6 ; NIL operation ; DIG 2 ; DUP ; DUG 3 ; CONS ; PAIR ; DIP { DROP 3 } } { DUP ; MAP { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; CDR ; COMPARE ; NEQ ; IF { PUSH string "TOKEN_UNDEFINED" ; FAILWITH } { DUP ; CDR ; CDR ; DIG 1 ; DUP ; DUG 2 ; CDR ; CAR ; SOME ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; CDR ; SOME ; DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; PAIR ; PAIR } ; DIP { DROP } } ; DIG 4 ; DUP ; DUG 5 ; CAR ; CDR ; CAR ; DIG 5 ; DUP ; DUG 6 ; CAR ; CDR ; CDR ; CAR ; CDR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DUP ; CAR ; CDR ; IF_LEFT { DUP ; IF_LEFT { PUSH string "TX_DENIED" ; FAILWITH } { PUSH bool True ; PUSH bool True ; PAIR ; DIP { DROP } } ; DIP { DROP } } { PUSH bool False ; PUSH bool True ; PAIR ; DIP { DROP } } ; SENDER ; EMPTY_SET address ; DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; ITER { SWAP ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; CAR ; CDR ; IF_NONE { DUP } { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PUSH bool True ; SWAP ; UPDATE ; DIP { DROP } } ; DIP { DROP 2 } } ; DUP ; ITER { DIG 2 ; DUP ; DUG 3 ; DIG 1 ; DUP ; DUG 2 ; COMPARE ; EQ ; DIG 4 ; DUP ; DUG 5 ; CAR ; AND ; IF { UNIT } { DIG 3 ; DUP ; DUG 4 ; CDR ; NOT ; IF { PUSH string "NOT_OWNER" ; FAILWITH } { DIG 4 ; DUP ; DUG 5 ; CDR ; DIG 3 ; DUP ; DUG 4 ; DIG 2 ; DUP ; DUG 3 ; PAIR ; GET ; IF_NONE { PUSH string "NOT_OPERATOR" ; FAILWITH } { DROP ; UNIT } } } ; DROP 2 } ; DROP 4 ; PUSH unit Unit ; DIG 5 ; DUP ; DUG 6 ; CAR ; CAR ; CAR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DIG 16 ; DUP ; DUG 17 ; SWAP ; EXEC ; DIG 6 ; DUP ; DUG 7 ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CDR ; SWAP ; CAR ; DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; PAIR ; NIL operation ; PAIR ; DIP { DROP 4 } } ; DIP { DROP } } { DIG 2 ; DUP ; DUG 3 ; CAR ; CDR ; CAR ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; ITER { SWAP ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; IF_LEFT { DUP ; CDR ; DIG 16 ; DUP ; DUG 17 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; PUSH bool True ; SOME ; DIG 3 ; DUP ; DUG 4 ; CAR ; CAR ; DIG 4 ; DUP ; DUG 5 ; CAR ; CDR ; PAIR ; UPDATE ; DIP { DROP 2 } } { DUP ; CDR ; DIG 16 ; DUP ; DUG 17 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; DIG 2 ; DUP ; DUG 3 ; CAR ; CAR ; DIG 3 ; DUP ; DUG 4 ; CAR ; CDR ; PAIR ; NONE bool ; SWAP ; UPDATE ; DIP { DROP 2 } } ; DIP { DROP 2 } } ; DIP { DROP } ; DIG 3 ; DUP ; DUG 4 ; DIG 1 ; DUP ; DUG 2 ; DIP { DUP ; CDR ; SWAP ; CAR ; DUP ; CAR ; SWAP ; CDR ; CDR } ; PAIR ; SWAP ; PAIR ; PAIR ; NIL operation ; PAIR ; DIP { DROP 2 } } ; DIP { DROP } } ; DIP { DROP 2 } ; DIG 4 ; DUP ; DUG 5 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP } } { DIG 1 ; DUP ; DUG 2 ; CAR ; DIG 3 ; DUP ; DUG 4 ; SWAP ; EXEC ; DIG 2 ; DUP ; DUG 3 ; CDR ; DIG 2 ; DUP ; DUG 3 ; PAIR ; DUP ; CDR ; DIG 1 ; DUP ; DUG 2 ; CAR ; IF_LEFT { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DIG 1 ; DUP ; DUG 2 ; MAP { PUSH nat 0 ; NONE address ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CDR ; SOME ; DIG 2 ; DUP ; DUG 3 ; CAR ; PAIR ; PAIR ; DIP { DROP } } ; SENDER ; SELF ; ADDRESS ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DIP { DROP } ; DIG 1 ; DUP ; DUG 2 ; CAR ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; CAR ; PAIR ; DIG 15 ; DUP ; DUG 16 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; DIG 13 ; DUP ; DUG 14 ; SWAP ; EXEC ; DUP ; DIG 4 ; DUP ; DUG 5 ; CDR ; SUB ; ISNAT ; DUP ; IF_NONE { PUSH string "INSUFFICIENT_BALANCE" ; FAILWITH } { DUP ; DIP { DROP } } ; DIG 5 ; DUP ; DUG 6 ; DIG 4 ; DUP ; DUG 5 ; DIP { DUP ; CDR ; SWAP ; CAR ; DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; SWAP ; CAR ; PAIR ; NIL operation ; PAIR ; DIP { DROP 9 } } { DIG 1 ; DUP ; DUG 2 ; DIG 1 ; DUP ; DUG 2 ; PAIR ; DUP ; CAR ; DIG 1 ; DUP ; DUG 2 ; CDR ; DIG 1 ; DUP ; DUG 2 ; MAP { PUSH nat 0 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SOME ; PAIR ; NONE address ; DIG 2 ; DUP ; DUG 3 ; CAR ; PAIR ; PAIR ; DIP { DROP } } ; SENDER ; SELF ; ADDRESS ; DIG 2 ; DUP ; DUG 3 ; PAIR ; PAIR ; DIP { DROP } ; DIG 1 ; DUP ; DUG 2 ; CAR ; CAR ; CAR ; DIG 1 ; DUP ; DUG 2 ; CAR ; CAR ; PAIR ; DIG 15 ; DUP ; DUG 16 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; DIG 13 ; DUP ; DUG 14 ; SWAP ; EXEC ; DIG 3 ; DUP ; DUG 4 ; DIG 2 ; DUP ; DUG 3 ; DIP { DUP ; CDR ; SWAP ; CAR ; DUP ; CDR ; SWAP ; CAR ; CDR } ; PAIR ; PAIR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; DIG 5 ; DUP ; DUG 6 ; CDR ; ADD ; SWAP ; CAR ; PAIR ; DUP ; NIL operation ; PAIR ; DIP { DROP 8 } } ; DIP { DROP 2 } ; DIG 3 ; DUP ; DUG 4 ; DIG 1 ; DUP ; DUG 2 ; CDR ; SWAP ; CAR ; PAIR ; DIG 1 ; DUP ; DUG 2 ; CAR ; PAIR ; DIP { DROP 3 } } ; DIP { DROP 8 } } ;`;
        const storage = `(Pair (Pair "${administrator}" ${pause ? 'True' : 'False'}) (Pair (Pair (Pair { } (Pair (Pair (Pair ${scale} { }) (Pair "${name}" "${symbol}")) ${tokenid})) (Pair { } (Pair (Pair None (Right Unit)) (Pair (Right Unit) (Right Unit))))) ${supply}))`;

        const nodeResult = await TezosNodeWriter.sendContractOriginationOperation(server, signer, keystore, 0, undefined, fee, freight, gas, contract, storage, TezosTypes.TezosParameterFormat.Michelson);
        return clearRPCOperationGroupHash(nodeResult['operationGroupID']);
    }

    export async function getSimpleStorage(server: string, address: string): Promise<any> {
        return null;
    }

    export async function getAccountBalance(server: string, mapid: number, account: string): Promise<number> {
        return 0;
    }

    function clearRPCOperationGroupHash(hash: string) {
        return hash.replace(/\"/g, '').replace(/\n/, '');
    }
}